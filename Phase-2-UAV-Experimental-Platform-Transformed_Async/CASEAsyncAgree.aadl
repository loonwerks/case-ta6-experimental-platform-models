package CASEAsyncAgree
public

	with CASE_Model_Transformations;
	renames CASE_Model_Transformations::all;
	renames Base_Types::all;

	with CMASI;
	with Data_Model;
	with Base_Types;

	data simple_int_array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Integer));
			Data_Model::Dimension => (3);
	end simple_int_array;

	annex agree {**	
--		const NULL_ID : int = 0;
--		const NULL_HEADER : CASE_MsgHeader.Impl = CASE_MsgHeader.Impl {src = NULL_ID; dst = NULL_ID; trusted = true; HMAC = true};
--		const NULL_UART_MSG : CASE_Model_Transformations::CASE_UART_Msg.Impl = CASE_Model_Transformations::CASE_UART_Msg.Impl {crc = true};
--		const NULL_RF_MSG : CASE_Model_Transformations::CASE_RF_Msg.Impl = CASE_Model_Transformations::CASE_RF_Msg.Impl {header = NULL_HEADER};		
--		const NULL_INT64_ARRAY : CMASI::Int64Array = [| 0 |];
--		const NULL_KEY_VALUE_PAIR : CMASI::KeyValuePair.i = CMASI::KeyValuePair.i {Key = 0; Value = 0};
--		const NULL_KEY_VALUE_PAIR_ARRAY : CMASI::KeyValuePairArray = [| NULL_KEY_VALUE_PAIR|];
--		const NULL_WEDGE : CMASI::Wedge.i =  CMASI::Wedge.i {AzimuthCenterline = 0.0; VerticalCenterline = 0.0; AzimuthExtent = 0.0; VerticalExtent = 0.0};
--		const NULL_WEDGE_ARRAY : CMASI::WedgeArray = [| NULL_WEDGE, NULL_WEDGE |];
--		const NULL_WAVELENGTH_BAND : CMASI::WavelengthBand = enum(CMASI::WavelengthBand, Other); 
--		const NULL_VEHICLE_ACTION : CMASI::VehicleAction.i = CMASI::VehicleAction.i {AssociatedTaskList = NULL_INT64_ARRAY};
--		const NULL_VEHICLE_ACTION_LIST : CMASI::VehicleActionArray = [| NULL_VEHICLE_ACTION |];		
--		const NULL_COMMAND_STATUS : CMASI::CommandStatusType = enum(CMASI::CommandStatusType, Cancelled);
--		const NULL_SPEED_TYPE : CMASI::SpeedType = enum(CMASI::SpeedType, Airspeed);
--		const NULL_ALTITUDE_TYPE : CMASI::AltitudeType = enum(CMASI::AltitudeType, AGL); 
--		const NULL_TURN_TYPE : CMASI::TurnType = enum(CMASI::TurnType, TurnShort);  				
--		const NULL_WAYPOINT : CMASI::Waypoint.i = CMASI::Waypoint.i { Latitude = -1.0; Longitude = -1.0; Altitude = -100.0; AltitudeType = NULL_ALTITUDE_TYPE; 
--							Number = 0; NextWaypoint = 0; Speed = 0.0; SpeedType = NULL_SPEED_TYPE;	ClimbRate = 0.0; TurnType = NULL_TURN_TYPE; 
--							VehicleActionList = NULL_VEHICLE_ACTION_LIST; ContingencyWaypointA = 0; ContingencyWaypointB = 0; AssociatedTasks = NULL_INT64_ARRAY}; 		
--		const NULL_WAYPOINT_LIST : CMASI::WaypointArray = [| NULL_WAYPOINT, NULL_WAYPOINT, NULL_WAYPOINT, NULL_WAYPOINT |];
--		const NULL_MISSION_COMMAND : CMASI::MissionCommand.i = CMASI::MissionCommand.i { CommandID = 0; VehicleID = 0; VehicleActionList = NULL_VEHICLE_ACTION_LIST; Status = NULL_COMMAND_STATUS; WaypointList = NULL_WAYPOINT_LIST; FirstWaypoint = 0};
--		const NULL_MISSION_COMMAND_LIST : CMASI::MissionCommandArray = [| NULL_MISSION_COMMAND |];
--		const NULL_VEHICLE_ACTION_COMMAND : CMASI::VehicleActionCommand.i = CMASI::VehicleActionCommand.i {CommandID = 0; VehicleID = 0; VehicleActionList = NULL_VEHICLE_ACTION_LIST; Status = NULL_COMMAND_STATUS};
--		const NULL_VEHICLE_ACTION_COMMAND_LIST : CMASI::VehicleActionCommandArray = [| NULL_VEHICLE_ACTION_COMMAND |];
--		const NULL_AUTOMATION_RESPONSE : CMASI::AutomationResponse.i = CMASI::AutomationResponse.i { MissionCommandList = NULL_MISSION_COMMAND_LIST; VehicleCommandList = NULL_VEHICLE_ACTION_COMMAND_LIST};
--		const NULL_POLYGON : CMASI::Polygon.i = CMASI::Polygon.i { BoundaryPointsList = NULL_POINT_LIST }; 
--		const NULL_POINT_LIST : CMASI::Location3DArray = [| NULL_3D_LOCATION, NULL_3D_LOCATION|];
--		const NULL_3D_LOCATION : CMASI::Location3D.i = CMASI::Location3D.i { Latitude = -1.0; Longitude = -1.0; Altitude = -100.0; AltitudeType = NULL_ALTITUDE_TYPE };
--		const NULL_OPERATING_REGION : CMASI::OperatingRegion.i = CMASI::OperatingRegion.i { ID = 0; KeepInAreas = NULL_INT64_ARRAY; KeepOutAreas = NULL_INT64_ARRAY };
--		const NULL_LINE_SEARCH_TASK : CMASI::LineSearchTask.i = CMASI::LineSearchTask.i {TaskID = 0; EligibleEntities = NULL_INT64_ARRAY;
--										RevisitRate = 0.0; Parameters = NULL_KEY_VALUE_PAIR_ARRAY; Priority = 0; Required = false; DesiredWavelengthBands = NULL_WAVELENGTH_BAND;
--										DwellTime = 0; GroundSampleDistance = 0.0; PointList = NULL_POINT_LIST; ViewAngleList = NULL_WEDGE_ARRAY; UseInertialViewAngles = false};
--		const NULL_AUTOMATION_REQUEST : CMASI::AutomationRequest.i = CMASI::AutomationRequest.i {EntityList= NULL_INT64_ARRAY; TaskList = NULL_INT64_ARRAY; TaskListSize = 0; OperatingRegion = 0; RedoAllTasks = false};	
--		-------------------------------------------------------
--		-- Scheduling and Execution Events 
--		-------------------------------------------------------		
--		node Get_Port_Output_Time_Event(activate: bool, deactivate: bool)
--		returns (output_time: bool);				
--		let
--			output_time = deactivate;
--		tel;		
--					
--		node Get_Port_Input_Time_Event(activate: bool, deactivate: bool)
--		returns (input_time: bool);		
--		let
--			input_time = activate;
--		tel;			
--					
--		node Get_Thread_Complete_Event(activate: bool, deactivate: bool)
--		returns (complete: bool);			
--		let
--			complete = deactivate;
--		tel;
--		-------------------------------------------------------
--		-- Get Input Event and Value 
--		-------------------------------------------------------				
--		node Get_Input_Event (input_event : bool, input_time: bool)
--		returns (output:  bool);
--		var input_hold : bool; 
--			input_time_delay_one  : bool;
--		let
--			input_time_delay_one  =  prev(input_time, false);
--			input_hold = SR_Latch(input_event, input_time_delay_one);
--			output = if input_time then input_hold
--				else prev(output, false);					
--		tel;
--
--		node Get_Input_Data_Zone (input : CMASI::Polygon.i, input_time: bool)
--		returns (output:  CMASI::Polygon.i);
--		let
--			output = if input_time then input
--					else prev(output, NULL_POLYGON);										
--		tel;
--		
--		node Get_Input_Data_UART_Msg (input : CASE_Model_Transformations::CASE_UART_Msg.Impl, input_event: bool, input_time: bool)
--		returns (output:  CASE_Model_Transformations::CASE_UART_Msg.Impl);
----		var input_hold : CASE_Model_Transformations::CASE_UART_Msg.Impl; 
----			input_time_delay_one  : bool;
--		let
----			input_time_delay_one  =  prev(input_time, false);
----			input_hold = SR_Latch_UART_Msg(input, input_event, input_time_delay_one);
----			output = if input_time then input_hold
--			output = if input_event then input
--					else prev(output, NULL_UART_MSG);
----			output = NULL_UART_MSG;					
----			output = NULL_UART_MSG -> pre(output);
--		tel;
--			
--		node Get_Input_Data_RF_Msg (input : CASE_Model_Transformations::CASE_RF_Msg.Impl, input_event: bool, input_time: bool)
--		returns (output:  CASE_Model_Transformations::CASE_RF_Msg.Impl);
----		var input_hold : CASE_Model_Transformations::CASE_RF_Msg.Impl; 
----			input_time_delay_one  : bool;
--		let
----			input_time_delay_one  =  prev(input_time, false);
----			input_hold = SR_Latch_RF_Msg(input, input_event, input_time_delay_one);
----			output = if input_time then input_hold
--			output = if input_event then input
--					else prev(output, NULL_RF_MSG);					
--		tel;
--				
--		node Get_Input_Data_Line_Search_Task (input : CMASI::LineSearchTask.i, input_event : bool, input_time: bool)
--		returns (output:  CMASI::LineSearchTask.i);
--		let
--			output = if input_event then input 
--					else prev(output, NULL_LINE_SEARCH_TASK);		
--		tel;
--
--		node Get_Input_Data_Automation_Request (input : CMASI::AutomationRequest.i, input_event : bool, input_time: bool)
--		returns (output:  CMASI::AutomationRequest.i);
--		let
--			output = if input_event then input  
--					else prev(output, NULL_AUTOMATION_REQUEST);		
--		tel;
--			
--		node Get_Input_Data_Automation_Response (input : CMASI::AutomationResponse.i, input_event : bool, input_time: bool)
--		returns (output:  CMASI::AutomationResponse.i);
----		var input_hold : CMASI::AutomationResponse.i; 
----			input_time_delay_one  : bool;
--		let
----			input_time_delay_one  =  prev(input_time, false);
----			input_hold = SR_Latch_Automation_Response(input, input_event, input_time_delay_one);
----			output = if input_time then input_hold 
--			output = if input_event then input 
--					else prev(output, NULL_AUTOMATION_RESPONSE);		
--		tel;
--									
--		node Get_Input_Data_Mission_Command (input : CMASI::MissionCommand.i, input_event : bool, input_time: bool)
--		returns (output:  CMASI::MissionCommand.i);
----		var input_hold : CMASI::MissionCommand.i; 
----			input_time_delay_one  : bool;
--		let
----			input_time_delay_one  =  prev(input_time, false);
----			input_hold = SR_Latch_Mission_Command(input, input_event, input_time_delay_one);
----			output = if input_time then input_hold
--			output = if input_event then input 
--					else prev(output, NULL_MISSION_COMMAND);		
--		tel;
--				
--		node Get_Input_Data_Operating_Region (input : CMASI::OperatingRegion.i, input_event : bool, input_time: bool)
--		returns (output:  CMASI::OperatingRegion.i);
--		var input_hold : CMASI::OperatingRegion.i; 
--			input_time_delay_one  : bool;
--		let
--			input_time_delay_one  =  prev(input_time, false);
--			input_hold = SR_Latch_Operating_Region(input, input_event, input_time_delay_one);
--			output = if input_time then input_hold 
--					else prev(output, NULL_OPERATING_REGION);		
--		tel;
--		-------------------------------------------------------
--		-- Get Output Event and Data (Hold Output Data)
--		-------------------------------------------------------	
--		node Get_Output_Event (output_event : bool, trigger: bool)
--		returns (output:  bool);
--		let
--			output = if trigger then output_event
--					 else prev(output, false);				
--		tel;
--				
--		node Get_Output_Data_Air_Vehicle_State(input: CMASI::AirVehicleState.i, trigger: bool)
--		returns (output: CMASI::AirVehicleState.i);
--		let
--			output = if trigger then input
--					 else prev(output, input);
--		tel;
--		
--		node Get_Output_Data_UART_Msg(input: CASE_Model_Transformations::CASE_UART_Msg.Impl, trigger: bool)
--		returns (output: CASE_Model_Transformations::CASE_UART_Msg.Impl);
--		let
--			output = if trigger then input
--					 else prev(output, NULL_UART_MSG);
--		tel;
--		
--		node Get_Output_Data_RF_Msg(input: CASE_Model_Transformations::CASE_RF_Msg.Impl, trigger: bool)
--		returns (output: CASE_Model_Transformations::CASE_RF_Msg.Impl);
--		let
--			output = if trigger then input
--					 else prev(output, NULL_RF_MSG);	
--		tel;
--			
--		node Get_Output_Data_Mission_Command(input: CMASI::MissionCommand.i, trigger: bool)
--		returns (output: CMASI::MissionCommand.i);
--		let
--			output = if trigger then input
--					 else prev(output, NULL_MISSION_COMMAND);	
--		tel;
--				
--		node Get_Output_Data_Automation_Request(input: CMASI::AutomationRequest.i, trigger: bool)
--		returns (output: CMASI::AutomationRequest.i);
--		let
--			output = if trigger then input
--					 else prev(output, input);	
--		tel;
--					
--		node Get_Output_Data_Line_Search_Task(input: CMASI::LineSearchTask.i, trigger: bool)
--		returns (output: CMASI::LineSearchTask.i);
--		let
--			output = if trigger then input
--					 else prev(output, input);	
--		tel;
--						
--		node Get_Output_Data_Operating_Region(input: CMASI::OperatingRegion.i, trigger: bool)
--		returns (output: CMASI::OperatingRegion.i);
--		let
--			output = if trigger then input
--					 else prev(output, NULL_OPERATING_REGION);	
--		tel;
--					
--		node Get_Output_Data_Automation_Response(input: CMASI::AutomationResponse.i, trigger: bool)
--		returns (output: CMASI::AutomationResponse.i);
--		let
--			output = if trigger then input
--					 else prev(output, NULL_AUTOMATION_RESPONSE);	
--		tel;	
--		
--		-------------------------------------------------------
--		-- SR Latches 
--		-------------------------------------------------------					
--		
----		node SR_Latch_Line_Search_Task (input: CMASI::LineSearchTask.i, set : bool, reset : bool) 
----		returns (output: CMASI::LineSearchTask.i);
----		let 
----			output = if set then input
----					else if reset then NULL_LINE_SEARCH_TASK
----					else prev(output, NULL_LINE_SEARCH_TASK);
----		tel;	
--		
--		node SR_Latch_Operating_Region (input: CMASI::OperatingRegion.i, set : bool, reset : bool) 
--		returns (output: CMASI::OperatingRegion.i);
--		let 
--			output = if set then input
--					else if reset then NULL_OPERATING_REGION
--					else prev(output, NULL_OPERATING_REGION);
--		tel;		
--		
--		node SR_Latch_Mission_Command (input: CMASI::MissionCommand.i, set : bool, reset : bool) 
--		returns (output: CMASI::MissionCommand.i);
--		let 
--			output = if set then input
--					else if reset then NULL_MISSION_COMMAND
--					else prev(output, NULL_MISSION_COMMAND);
--		tel;
--
----		node SR_Latch_Automation_Request (input: CMASI::AutomationRequest.i, set : bool, reset : bool) 
----		returns (output: CMASI::AutomationRequest.i);
----		let 
----			output = if set then input
----					else if reset then NULL_AUTOMATION_REQUEST
----					else prev(output, NULL_AUTOMATION_REQUEST);
----		tel;
--									
--		node SR_Latch_Automation_Response (input: CMASI::AutomationResponse.i, set : bool, reset : bool) 
--		returns (output: CMASI::AutomationResponse.i);
--		let 
--			output = if set then input
--					else if reset then NULL_AUTOMATION_RESPONSE
--					else prev(output, NULL_AUTOMATION_RESPONSE);
--		tel;
--		
--		node SR_Latch_UART_Msg (input: CASE_Model_Transformations::CASE_UART_Msg.Impl, set : bool, reset : bool) 
--		returns (output: CASE_Model_Transformations::CASE_UART_Msg.Impl);
--		let 
--			output = if set then input
--					else if reset then NULL_UART_MSG
--					else prev(output, NULL_UART_MSG);
--		tel;
--					
--		node SR_Latch_RF_Msg (input: CASE_Model_Transformations::CASE_RF_Msg.Impl, set : bool, reset : bool) 
--		returns (output: CASE_Model_Transformations::CASE_RF_Msg.Impl);
--		let 
--			output = if set then input
--					else if reset then NULL_RF_MSG
--					else prev(output, NULL_RF_MSG);
--		tel;
--					
--		-- Set over Reset SR latch (if reset over set, then input event is ignored on reset)
--		node SR_Latch (set : bool, reset : bool) 
--		returns (o: bool);
--		let 
--			o = if set then true
--				else if reset then false
--				else prev(o, false);
--		tel;

		-- Counter starts with init + incr, reset to init
		node Counter (init: int, incr: int, reset: bool)	
		returns (count: int);
		let
			count = if reset then init
					else init-> (pre(count) + incr);
		tel;
	**};

end CASEAsyncAgree;

