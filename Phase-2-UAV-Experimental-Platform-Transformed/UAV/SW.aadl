package SW
public
	with Drivers;
	with CASE_Model_Transformations;
	with CASEAgree;
	renames CASEAgree::all;
	with CASE_Properties;
	with CASE_Scheduling;
	with CMASI;
	renames AGREE_PLTL::all;
	with CM_Property_Set;
	with HAMR;


	------------------
	-- Radio Driver --
	------------------

	thread RadioDriver_Attestation_thr
		features
			am_request: in event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			am_response: out event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;

			recv_data: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
            send_data: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;

            AutomationRequest: out event data port CMASI::AddressAttributedMessage.i;
            OperatingRegion: out event data port CMASI::AddressAttributedMessage.i;
            LineSearchTask: out event data port CMASI::AddressAttributedMessage.i;			
		properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 20ms .. 20ms;
			Stack_Size => CM_Property_Set::Stack_Size;
        annex agree {**
            assume "The radio receives well-formed messages" : 
                event(recv_data) => WellformedCASE_RF_Msg(recv_data, GS_ID, UAV_ID);
            guarantee Req001_SW1 "The radio_send outputs only well formed CASE_RF_Msg.Impl types" :
                 event(send_data) => WellformedCASE_RF_Msg(send_data, UAV_ID, GS_ID);
        **};
	end RadioDriver_Attestation_thr;

	thread implementation RadioDriver_Attestation_thr.Impl
	end RadioDriver_Attestation_thr.Impl;

	process RadioDriver_Attestation
		features
			am_request: in event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			am_response: out event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;

			recv_data: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			send_data: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;

			AutomationRequest: out event data port CMASI::AddressAttributedMessage.i;
			OperatingRegion: out event data port CMASI::AddressAttributedMessage.i;
			LineSearchTask: out event data port CMASI::AddressAttributedMessage.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::RadioDriver_Attestation_Domain;
			HAMR::Component_Type => VIRTUAL_MACHINE;
	end RadioDriver_Attestation;

	process implementation RadioDriver_Attestation.Impl
		subcomponents
			RadioDriver_Attestation: thread RadioDriver_Attestation_thr.Impl;
		connections
			c1: port am_request -> RadioDriver_Attestation.am_request;
			c2: port RadioDriver_Attestation.am_response -> am_response;
			c3: port recv_data -> RadioDriver_Attestation.recv_data;
			c4: port RadioDriver_Attestation.send_data -> send_data;
			c5: port RadioDriver_Attestation.AutomationRequest -> AutomationRequest;
			c6: port RadioDriver_Attestation.OperatingRegion -> OperatingRegion;
			c7: port RadioDriver_Attestation.LineSearchTask -> LineSearchTask;
	
	    annex agree {**
            lift contract;
        **};
	end RadioDriver_Attestation.Impl;

	---------------------
	-- Attestation
	---------------------

	thread CASE_AttestationManager_thr
		features
			trusted_ids: out data port CMASI::AddressArray.i;
			attestation_request: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			attestation_response: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::Attesting => 100;
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
		annex agree {**
		    guarantee "Trusted IDs are valid" : true;
		**};
	end CASE_AttestationManager_thr;

	thread implementation CASE_AttestationManager_thr.Impl
		properties
			CASE_Properties::Component_Impl => "CakeML";
			CASE_Properties::Cache_Timeout => 30 min;
			CASE_Properties::Cache_Size => 3;
			Dispatch_Protocol => Periodic;
			Stack_Size => CM_Property_Set::Stack_Size;
	end CASE_AttestationManager_thr.Impl;

	process CASE_AttestationManager
		features
			trusted_ids: out data port CMASI::AddressArray.i;
			attestation_request: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			attestation_response: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Scheduling::Domain => 4;
	end CASE_AttestationManager;

	process implementation CASE_AttestationManager.Impl
		subcomponents
			CASE_AttestationManager: thread CASE_AttestationManager_thr.Impl;
		connections
			c1: port CASE_AttestationManager.trusted_ids -> trusted_ids;
			c2: port CASE_AttestationManager.attestation_request -> attestation_request;
			c3: port attestation_response -> CASE_AttestationManager.attestation_response;
        
        annex agree {**
            lift contract;
        **};
	end CASE_AttestationManager.Impl;

	---------------------
	-- Attestation Gate
	---------------------

	thread CASE_AttestationGate_thr
		features
			trusted_ids: in data port CMASI::AddressArray.i;
			AutomationRequest_in: in event data port CMASI::AddressAttributedMessage.i;
			AutomationRequest_out: out event data port CMASI::AutomationRequest.i;
			OperatingRegion_in: in event data port CMASI::AddressAttributedMessage.i;
			OperatingRegion_out: out event data port CMASI::OperatingRegion.i;
			LineSearchTask_in: in event data port CMASI::AddressAttributedMessage.i;
			LineSearchTask_out: out event data port CMASI::LineSearchTask.i;
		properties
			CASE_Properties::Monitoring => 100;
			CASE_Properties::Component_Spec => ("CASE_AttestationGate_policy");
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			guarantee CASE_AttestationGate_policy "Only messages from trusted sources shall be forwarded" :
				if event(AutomationRequest_in) and IS_TRUSTED(trusted_ids, AutomationRequest_in.id) then event(AutomationRequest_out) and not (event(OperatingRegion_out) or event(LineSearchTask_out)) and AutomationRequest_out = AutomationRequest_in.payload.AutomationRequest
				else if event(OperatingRegion_in) and IS_TRUSTED(trusted_ids, OperatingRegion_in.id) then event(OperatingRegion_out) and not (event(AutomationRequest_out) or event(LineSearchTask_out)) and OperatingRegion_out = OperatingRegion_in.payload.OperatingRegion
				else if event(LineSearchTask_in) and IS_TRUSTED(trusted_ids, LineSearchTask_in.id) then event(LineSearchTask_out) and not (event(AutomationRequest_out) or event(OperatingRegion_out)) and LineSearchTask_out = LineSearchTask_in.payload.LineSearchTask
				else not (event(AutomationRequest_out) or event(OperatingRegion_out) or event(LineSearchTask_out));
--          EGM: TOGGLE TO TURN OFF ATTESTATION
--			guarantee CASE_AttestationGate_no_policy "All messages shall be forwarded" :
--                if event(AutomationRequest_in) then event(AutomationRequest_out) and not (event(OperatingRegion_out) or event(LineSearchTask_out)) and AutomationRequest_out = AutomationRequest_in.payload.AutomationRequest
--                else if event(OperatingRegion_in) then event(OperatingRegion_out) and not (event(AutomationRequest_out) or event(LineSearchTask_out)) and OperatingRegion_out = OperatingRegion_in.payload.OperatingRegion
--                else if event(LineSearchTask_in) then event(LineSearchTask_out) and not (event(AutomationRequest_out) or event(OperatingRegion_out)) and LineSearchTask_out = LineSearchTask_in.payload.LineSearchTask
--                else not (event(AutomationRequest_out) or event(OperatingRegion_out) or event(LineSearchTask_out));
			
		**};
	end CASE_AttestationGate_thr;

	thread implementation CASE_AttestationGate_thr.Impl
	end CASE_AttestationGate_thr.Impl;

	process CASE_AttestationGate
		features
			trusted_ids: in data port CMASI::AddressArray.i;
			AutomationRequest_in: in event data port CMASI::AddressAttributedMessage.i;
			AutomationRequest_out: out event data port CMASI::AutomationRequest.i;
			OperatingRegion_in: in event data port CMASI::AddressAttributedMessage.i;
			OperatingRegion_out: out event data port CMASI::OperatingRegion.i;
			LineSearchTask_in: in event data port CMASI::AddressAttributedMessage.i;
			LineSearchTask_out: out event data port CMASI::LineSearchTask.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::CASE_AttestationGate_Domain;
	end CASE_AttestationGate;

	process implementation CASE_AttestationGate.Impl
		subcomponents
			CASE_AttestationGate: thread CASE_AttestationGate_thr.Impl;
		connections
			c1: port trusted_ids -> CASE_AttestationGate.trusted_ids;
			c2: port AutomationRequest_in -> CASE_AttestationGate.AutomationRequest_in;
			c3: port CASE_AttestationGate.AutomationRequest_out -> AutomationRequest_out;
			c4: port OperatingRegion_in -> CASE_AttestationGate.OperatingRegion_in;
			c5: port CASE_AttestationGate.OperatingRegion_out -> OperatingRegion_out;
			c6: port LineSearchTask_in -> CASE_AttestationGate.LineSearchTask_in;
			c7: port CASE_AttestationGate.LineSearchTask_out -> LineSearchTask_out;
	
	   annex agree {**
            lift contract;
        **}; 
	end CASE_AttestationGate.Impl;


	-------------------------------------
	-- Line Search Task message Filter --
	-------------------------------------

	thread CASE_Filter_LST_thr
		features
			filter_in: in event data port CMASI::LineSearchTask.i;
			filter_out: out event data port CMASI::LineSearchTask.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("Req_Filter_LST");
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			guarantee Req_Filter_LST "Well-formed Line Search Task message" :
			if event(filter_in) and WELL_FORMED_LINE_SEARCH_TASK(filter_in) then
			   event(filter_out) and (filter_out = filter_in)
			else not(event(filter_out));
		**};
	end CASE_Filter_LST_thr;

	thread implementation CASE_Filter_LST_thr.Impl
	end CASE_Filter_LST_thr.Impl;

	process CASE_Filter_LST
		features
			filter_in: in event data port CMASI::LineSearchTask.i;
			filter_out: out event data port CMASI::LineSearchTask.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::CASE_Filter_LST_Domain;
	end CASE_Filter_LST;

	process implementation CASE_Filter_LST.Impl
		subcomponents
			CASE_Filter_LST: thread CASE_Filter_LST_thr.Impl;
		connections
			c1: port filter_in -> CASE_Filter_LST.filter_in;
			c2: port CASE_Filter_LST.filter_out -> filter_out;

        annex agree {**
            lift contract;
        **};
	end CASE_Filter_LST.Impl;


	-------------------------------------
	-- Operating Region message Filter --
	-------------------------------------

	thread CASE_Filter_OR_thr
		features
			filter_in: in event data port CMASI::OperatingRegion.i;
			filter_out: out event data port CMASI::OperatingRegion.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("Req_Filter_OR");
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			guarantee Req_Filter_OR "Well-formed Operating Region message" :
			if event(filter_in) and WELL_FORMED_OPERATING_REGION(filter_in) then
			   event(filter_out) and (filter_out = filter_in)
			else not(event(filter_out));
		**};
	end CASE_Filter_OR_thr;

	thread implementation CASE_Filter_OR_thr.Impl
	end CASE_Filter_OR_thr.Impl;

	process CASE_Filter_OR
		features
			filter_in: in event data port CMASI::OperatingRegion.i;
			filter_out: out event data port CMASI::OperatingRegion.i;
		properties
			CASE_Scheduling::Domain => 8;
	end CASE_Filter_OR;

	process implementation CASE_Filter_OR.Impl
		subcomponents
			CASE_Filter_OR: thread CASE_Filter_OR_thr.Impl;
		connections
			c1: port filter_in -> CASE_Filter_OR.filter_in;
			c2: port CASE_Filter_OR.filter_out -> filter_out;

        annex agree {**
            lift contract;
        **};
	end CASE_Filter_OR.Impl;


	---------------------------------------
	-- Automation Request message Filter --
	---------------------------------------

	thread CASE_Filter_AReq_thr
		features
			filter_in: in event data port CMASI::AutomationRequest.i;
			filter_out_UXAS: out event data port CMASI::AutomationRequest.i;
			filter_out_MON_REQ: out event data port CMASI::AutomationRequest.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("Req_Filter_AReq");
			Dispatch_Protocol => Periodic;

			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			guarantee Req_Filter_AReq "Well-formed Automation Request message" :
			if event(filter_in) and WELL_FORMED_AUTOMATION_REQUEST(filter_in) then
			   event(filter_out_UXAS) and
			   event(filter_out_MON_REQ) and
			   (filter_out_UXAS = filter_in) and
			   (filter_out_MON_REQ = filter_in)
		 else not (event (filter_out_UXAS)) and
		      not (event(filter_out_MON_REQ));
		**};
	end CASE_Filter_AReq_thr;

	thread implementation CASE_Filter_AReq_thr.Impl
	end CASE_Filter_AReq_thr.Impl;

	process CASE_Filter_AReq
		features
			filter_in: in event data port CMASI::AutomationRequest.i;
			filter_out_UXAS: out event data port CMASI::AutomationRequest.i;
			filter_out_MON_REQ: out event data port CMASI::AutomationRequest.i;
		properties
			CASE_Scheduling::Domain => 6;
	end CASE_Filter_AReq;

	process implementation CASE_Filter_AReq.Impl
		subcomponents
			CASE_Filter_AReq: thread CASE_Filter_AReq_thr.Impl;
		connections
			c1: port filter_in -> CASE_Filter_AReq.filter_in;
			c2: port CASE_Filter_AReq.filter_out_UXAS -> filter_out_UXAS;
			c3: port CASE_Filter_AReq.filter_out_MON_REQ -> filter_out_MON_REQ;

        annex agree {**
            lift contract;
        **};
	end CASE_Filter_AReq.Impl;


	----------
	-- UxAS --
	----------

	thread UxAS_thr
        features
            AutomationRequest : in event data port CMASI::AutomationRequest.i;
            AirVehicleState : in event data port CMASI::AirVehicleState.i;
            OperatingRegion : in event data port CMASI::OperatingRegion.i;
            LineSearchTask: in event data port CMASI::LineSearchTask.i;
            AutomationResponse : out event data port CMASI::AutomationResponse.i;
        properties
            Dispatch_Protocol => Periodic;
            Period => 500ms;
            Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
		    eq wellFormedAutomationRequest : bool =
                event(AutomationRequest) =>
                            WELL_FORMED_AUTOMATION_REQUEST(AutomationRequest);
            eq wellFormedLineSearchTask : bool =
                event(LineSearchTask) =>
                            WELL_FORMED_LINE_SEARCH_TASK(LineSearchTask);
            eq wellFormedOperatingRegion : bool =
                event(OperatingRegion) =>
                            WELL_FORMED_OPERATING_REGION(OperatingRegion);
            eq wellFormedAirVehicleState : bool =
                event(AirVehicleState) =>
                            WELL_FORMED_AIR_VEHICLE_STATE(AirVehicleState);

            assume "UXAS only receives well-formed messages" :
                (      wellFormedAutomationRequest
                   and wellFormedLineSearchTask
                   and wellFormedOperatingRegion
                   and wellFormedAirVehicleState
                );
		**};
    end UxAS_thr;

    thread implementation UxAS_thr.Impl
    end UxAS_thr.Impl;

	process UxAS
		features
			AutomationRequest : in event data port CMASI::AutomationRequest.i;
			AirVehicleState : in event data port CMASI::AirVehicleState.i;
			OperatingRegion : in event data port CMASI::OperatingRegion.i;
			LineSearchTask: in event data port CMASI::LineSearchTask.i;
            AutomationResponse : out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::UxAS_Domain;
--			HAMR::Component_Type => VIRTUAL_MACHINE;
	end UxAS;

	process implementation UxAS.Impl
		subcomponents
			UxAS: thread UxAS_thr.Impl;
		connections
			c1: port AutomationRequest -> UxAS.AutomationRequest;
			c2: port AirVehicleState -> UxAS.AirVehicleState;
			c3: port OperatingRegion -> UxAS.OperatingRegion;
			c4: port LineSearchTask -> UxAS.LineSearchTask;
			c6: port UxAS.AutomationResponse -> AutomationResponse;
	
	   annex agree {**
            lift contract;
        **};
	end UxAS.Impl;


	------------------------------
	-- Request-Response Monitor --
	------------------------------

	thread CASE_Monitor_Req_thr
		features
			reqt : in event data port CMASI::AutomationRequest.i;
			resp: in event data port CMASI::AutomationResponse.i;
			alert: out event port;
		properties
			CASE_Properties::Monitoring => 100; -- marks this component as a monitor
			CASE_Properties::Monitor_Latched => false; -- indicates if the monitor is latched
			CASE_Properties::Component_Spec => ("Req002_ReqRespMonitorEvent"); -- monitor guarantee
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**

            -- a constant generated from the component property above, handy for expressing the monitor guarantee
            const is_latched : bool = Get_Property(this, CASE_Properties::Monitor_Latched);

            -- Monitor policy expresses the expected behavior in terms of the input ports.
            -- AutomationResponse (resp) occurs within nMonitorInvocations after AutomationRequest (reqt)

            const nMonitorInvocations : int = 10; -- user-defined value for "days"

            const FAIL : int = nMonitorInvocations + 1;

            fun Inc (x:int) : int = if x < nMonitorInvocations then x+1 else FAIL;

            eq ticks : int =
                (if event(resp) then FAIL
                 else (if event (reqt) then 1 else 0))
                ->
                if (event(reqt) and event(resp)) then
                   FAIL
                else
                if not (event(reqt) or event(resp)) then
                   (if (pre(ticks) = 0) then 0 else Inc (pre(ticks)))
                else
                if event(resp) then
                   (if (1 <= pre(ticks)) then 0 else FAIL)
                else -- rqts set ticks to 1, so rqt.rqt.resp is fine
                   1;

            eq Policy : bool = ticks < nMonitorInvocations;

            guarantee Req002_ReqRespMonitorEvent
                "alert trace property, to be proved by SPLAT" :
                event(alert) <=>  (not Policy -> (if is_latched then Once (not Policy) else not Policy));
         **};
	end CASE_Monitor_Req_thr;

	thread implementation CASE_Monitor_Req_thr.Impl
	end CASE_Monitor_Req_thr.Impl;

	process CASE_Monitor_Req
		features
			resp: in event data port CMASI::AutomationResponse.i;
			reqt: in event data port CMASI::AutomationRequest.i;
			alert: out event port;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::CASE_Monitor_Req_Domain;
			CASE_Properties::Monitor_Latched => true;
	end CASE_Monitor_Req;

	process implementation CASE_Monitor_Req.Impl
		subcomponents
			CASE_Monitor_Req: thread CASE_Monitor_Req_thr.Impl;
		connections
			c1: port resp -> CASE_Monitor_Req.resp;
			c2: port reqt -> CASE_Monitor_Req.reqt;
			c3: port CASE_Monitor_Req.alert -> alert;
	
	   annex agree {**
            lift contract;
        **};
	end CASE_Monitor_Req.Impl;


    ---------------------------------------------------------
    -- Sync for alert output from Request Response Monitor --
    ---------------------------------------------------------
    thread alert_sync_thr
    	features
    		alert_in: in event port;
        properties
            Dispatch_Protocol => Periodic;
            Period => 500ms;
            Compute_Execution_Time => 2ms .. 2ms;
            Stack_Size => CM_Property_Set::Stack_Size;
    end alert_sync_thr;
        
    thread implementation alert_sync_thr.Impl
    end alert_sync_thr.Impl;
    
    process alert_sync
    	features
    		alert_in: in event port;
    end alert_sync;
    
    process implementation alert_sync.Impl
    	subcomponents
    		alert_sync: thread alert_sync_thr.Impl;
    	connections
    		c1: port alert_in -> alert_sync.alert_in;
   
        annex agree {**
            lift contract;
        **};
    end alert_sync.Impl;
    
	----------------------------------------
	-- Automation Response message Filter --
	----------------------------------------

	thread CASE_Filter_ARes_thr
		features
			filter_in: in event data port CMASI::AutomationResponse.i;
			filter_out: out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Properties::Filtering => 100;
			CASE_Properties::Component_Spec => ("Req_Filter_ARes");
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			guarantee Req_Filter_ARes "Well-formed Automation Response message" :
			if (event(filter_in) and WELL_FORMED_AUTOMATION_RESPONSE(filter_in)) then
			   (event(filter_out) and (filter_out = filter_in))
			               else not(event (filter_out));
		**};
	end CASE_Filter_ARes_thr;

	thread implementation CASE_Filter_ARes_thr.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter_ARes_thr.Impl;

	process CASE_Filter_ARes
		features
			filter_in: in event data port CMASI::AutomationResponse.i;
			filter_out: out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::CASE_Filter_ARes_Domain;
	end CASE_Filter_ARes;

	process implementation CASE_Filter_ARes.Impl
		subcomponents
			CASE_Filter_ARes: thread CASE_Filter_ARes_thr.Impl;
		connections
			c1: port filter_in -> CASE_Filter_ARes.filter_in;
			c2: port CASE_Filter_ARes.filter_out -> filter_out;

        annex agree {**
            lift contract;
        **};
	end CASE_Filter_ARes.Impl;

	------------------------
	-- Fly Zones Database --
	------------------------

	thread FlyZonesDatabase_thr
		-- The KeepInZoneDatabase is a collection of polygons that represent areas on a map that the UAV can traverse.
		-- The database is populated at build-time and stored in memory.
		features
			keep_in_zones: out data port CMASI::Polygon.i;
			keep_out_zones: out data port CMASI::Polygon.i;
    properties
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
	annex agree {**
		guarantee "Keep in zones do not change" : true -> keep_in_zones = pre(keep_in_zones);
		guarantee "Keep out zones do not change" : true -> keep_out_zones = pre(keep_out_zones);
		guarantee "Keep in zones are well-formed" : WELL_FORMED_ZONES(keep_in_zones);
		guarantee "keep oun zones are well-formed" : WELL_FORMED_ZONES(keep_out_zones);
    **};
	end FlyZonesDatabase_thr;

	thread implementation FlyZonesDatabase_thr.Impl
	end FlyZonesDatabase_thr.Impl;

	process FlyZonesDatabase
		features
			keep_in_zones: out data port CMASI::Polygon.i;
			keep_out_zones: out data port CMASI::Polygon.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::FlyZonesDatabase_Domain;
	end FlyZonesDatabase;

	process implementation FlyZonesDatabase.Impl
		subcomponents
			FlyZonesDatabase: thread FlyZonesDatabase_thr.Impl;
		connections
			c1: port FlyZonesDatabase.keep_in_zones -> keep_in_zones;
			c2: port FlyZonesDatabase.keep_out_zones -> keep_out_zones;
			
	    annex agree {**
            lift contract;
        **};
	end FlyZonesDatabase.Impl;


	----------------------
	-- Geofence Monitor --
	----------------------

	thread CASE_Monitor_Geo_thr
		features
			keep_in_zones: in data port CMASI::Polygon.i;
			keep_out_zones: in data port CMASI::Polygon.i;
			alert: out event port;
			observed: in event data port CMASI::AutomationResponse.i;
			output: out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Properties::Monitoring => 100; -- marks this component as a monitor
			CASE_Properties::Component_Spec => ("GeofenceMonitor_alert_event", "GeofenceMonitor_output_event", "GeofenceMonitor_output_data"); -- monitor guarantee
			CASE_Properties::Monitor_Latched => true; -- indicates if the monitor is latched
			Dispatch_Protocol => Periodic;
			Period => 500ms;
			Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
		annex agree {**
			-- a constant generated from the component property above, handy for expressing the monitor guarantee
			const is_latched : bool = Get_Property(this, CASE_Properties::Monitor_Latched);
                                    
			eq Policy : bool = 
                  event(observed) =>
                  (WAYPOINTS_IN_ZONE(GET_MISSION_COMMAND(observed), keep_in_zones)
                  and WAYPOINTS_NOT_IN_ZONE(GET_MISSION_COMMAND(observed), keep_out_zones)
                  and not (DUPLICATES_IN_MISSION(GET_MISSION_COMMAND(observed))));
                        
            guarantee GeofenceMonitor_alert 
             "alert trace property. To be proved by SPLAT" :
            event(alert) <=>  (not Policy -> (if is_latched then Once (not (Policy)) else not Policy));

            guarantee GeofenceMonitor_output 
            "The output event fires only when observed is valid and alert is not raised" :
                if event(alert) then 
                  not (event(output))
                else if event(observed) then
                        (event(output) and (output = observed))
                     else
                        not (event(output));
	   **};
	end CASE_Monitor_Geo_thr;

	thread implementation CASE_Monitor_Geo_thr.Impl
	end CASE_Monitor_Geo_thr.Impl;

	process CASE_Monitor_Geo
		features
			keep_in_zones: in data port CMASI::Polygon.i;
			keep_out_zones: in data port CMASI::Polygon.i;
			alert: out event port;
			observed: in event data port CMASI::AutomationResponse.i;
			output: out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::CASE_Monitor_Geo_Domain;
            CASE_Properties::Monitor_Latched => true;
	end CASE_Monitor_Geo;

	process implementation CASE_Monitor_Geo.Impl
		subcomponents
			CASE_Monitor_Geo: thread CASE_Monitor_Geo_thr.Impl;
		connections
			c1: port keep_in_zones -> CASE_Monitor_Geo.keep_in_zones;
			c2: port keep_out_zones -> CASE_Monitor_Geo.keep_out_zones;
			c3: port CASE_Monitor_Geo.alert -> alert;
			c4: port observed -> CASE_Monitor_Geo.observed;
			c5: port CASE_Monitor_Geo.output -> output;
	
	    annex agree {**
            lift contract;
        **};
	end CASE_Monitor_Geo.Impl;


	----------------------
	-- Waypoint Manager --
	----------------------

	thread WaypointPlanManagerService_thr
        features
            AutomationResponse: in event data port CMASI::AutomationResponse.i;
            AirVehicleState: in event data port CMASI::AirVehicleState.i;
            MissionCommand: out event data port CMASI::MissionCommand.i;
            ReturnHome: in event port;
        properties
            Dispatch_Protocol => Periodic;
            Period => 500ms;
            Compute_Execution_Time => 2ms .. 2ms;
			Stack_Size => CM_Property_Set::Stack_Size;
        annex agree {**
            assume Req_WPM_Mutex "The Waypoint Manager return home and automation response are mutually exclusive" :
                (     (event(ReturnHome) => not event(AutomationResponse))
                  and (event(AutomationResponse) => not event(ReturnHome))
                );
            assume Req_WPM_Good_Automation_Response "The Waypoint Manager shall receive valid automation responses" :
                event(AutomationResponse) => WELL_FORMED_AUTOMATION_RESPONSE(AutomationResponse);
            assume Req_WPM_Good_AirVehicle_State "The Waypoint Manager shall receive well-formed air vehicle states" :
                event(AirVehicleState) => WELL_FORMED_AIR_VEHICLE_STATE(AirVehicleState);
            guarantee Req_WPM_Good_Mission_Command "The Waypoint Manager shall output valid mission commands" : 
                event(MissionCommand) => WELL_FORMED_MISSION_COMMAND(MissionCommand);
        **};			
    end WaypointPlanManagerService_thr;

    thread implementation WaypointPlanManagerService_thr.Impl

    end WaypointPlanManagerService_thr.Impl;

	process WaypointPlanManagerService
		features
			-- Subscribed Messages
			AutomationResponse: in event data port CMASI::AutomationResponse.i;
			AirVehicleState: in event data port CMASI::AirVehicleState.i;
			-- Sent Messages
			MissionCommand: out event data port CMASI::MissionCommand.i;

			-- Return Home
			ReturnHome: in event port;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::WaypointPlanManangerService_Domain;
		
	end WaypointPlanManagerService;

	process implementation WaypointPlanManagerService.Impl
		subcomponents
			WaypointPlanManagerService: thread WaypointPlanManagerService_thr.Impl;
		connections
			c1: port AutomationResponse -> WaypointPlanManagerService.AutomationResponse;
			c2: port AirVehicleState -> WaypointPlanManagerService.AirVehicleState;
			c3: port WaypointPlanManagerService.MissionCommand -> MissionCommand;
			c4: port ReturnHome -> WaypointPlanManagerService.ReturnHome;
		annex agree {**
            lift contract;
        **};
	end WaypointPlanManagerService.Impl;


	-----------------
	-- UART Driver --
	-----------------

	process UARTDriver
		features
			recv_data: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			MissionCommand: in event data port CMASI::MissionCommand.i;

			send_data: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			AirVehicleState_WPM: out event data port CMASI::AirVehicleState.i;
			AirVehicleState_UXAS: out event data port CMASI::AirVehicleState.i;
		properties
			CASE_Scheduling::Domain => CM_Property_Set::UARTDriver_Domain;
	end UARTDriver;

	process implementation UARTDriver.Impl
		subcomponents
			UARTDriver: thread Drivers::UARTDriver.Impl;
		connections
			c1: port recv_data -> UARTDriver.recv_data;
			c2: port MissionCommand -> UARTDriver.MissionCommand;
			c3: port UARTDriver.send_data -> send_data;
			c4: port UARTDriver.AirVehicleState_WPM -> AirVehicleState_WPM;
			c5: port UARTDriver.AirVehicleState_UXAS -> AirVehicleState_UXAS;
	
	    annex agree {**
            lift contract;
        **};
	end UARTDriver.Impl;

	---------------------
	-- Software system --
	---------------------

	----------------------------------------------------------------------
    processor proc
    end proc;

    processor implementation proc.Impl
        properties
            Frame_Period => 1000ms;
            Clock_Period => 2ms;
            CASE_Scheduling::Max_Domain => 15;
            CASE_Scheduling::Schedule_Source_Text => "UAV/behavior_code/kernel/domain_schedule.c";
    end proc.Impl;
    ----------------------------------------------------------------------

	system SW
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
		annex agree {**        
		    assume "The radio receives well-formed messages" : event(radio_recv) => WellformedCASE_RF_Msg(radio_recv, GS_ID, UAV_ID);
            assume "The uart receives well-formed messages" : event(uart_recv) => WellformedCASE_UART_Msg(uart_recv);
            guarantee "The radio_send outputs only well formed CASE_RF_Msg.Impl types" : event(radio_send) => WellformedCASE_RF_Msg(radio_send, UAV_ID, GS_ID);
            guarantee "The uart_send outputs only well formed CASE_UART_Msg.Impl types" : event(uart_send) => WellformedCASE_UART_Msg(uart_send);
            
            -------------------------------------------------
            -- The system only responds to trusted sources --
            -------------------------------------------------
            eq trustedSourcesOnly : bool;
            guarantee "The system only responds to trusted sources" :
                trustedSourcesOnly;

            --------------------------------------------
            -- The uart_send waypoints are geo-fenced --
            --------------------------------------------
            eq geoFenced : bool;
            guarantee "The uart_send waypoints are geo-fenced" :
               geoFenced;

            -----------------------------------------------------------
            -- The uart_send waypoints correspond to the line search --
            -----------------------------------------------------------
            eq waypointsFromLineSearch : bool;
            guarantee "The uart_send waypoints correspond to the line search" :
                waypointsFromLineSearch;
 		**};
	end SW;

	system implementation SW.Impl
		subcomponents
			proc: processor proc.Impl;
			FC_UART: process UARTDriver.Impl;
			RADIO: process RadioDriver_Attestation.Impl;
			FlyZones: process FlyZonesDatabase.Impl;
			UXAS: process UxAS.Impl;
			WPM: process WaypointPlanManagerService.Impl;
			AM: process CASE_AttestationManager.Impl;
			AM_Gate: process CASE_AttestationGate.Impl;
			FLT_AReq: process CASE_Filter_AReq.Impl;
			FLT_OR: process CASE_Filter_OR.Impl;
			FLT_LST: process CASE_Filter_LST.Impl;
			MON_REQ: process CASE_Monitor_Req.Impl;
			ALERT_SYNC: process alert_sync.Impl;
			FLT_ARes: process CASE_Filter_ARes.Impl;
			MON_GEO: process CASE_Monitor_Geo.Impl;
		connections

	        --------------------
			-- Primary Inputs --
			--------------------
			c01: port uart_recv -> FC_UART.recv_data;
			c02: port radio_recv -> RADIO.recv_data;

			-------------
			-- FC_UART --
			-------------
			c03: port FC_UART.send_data -> uart_send;
			c04: port FC_UART.AirVehicleState_UXAS -> UXAS.AirVehicleState;
			c05: port FC_UART.AirVehicleState_WPM -> WPM.AirVehicleState;

			-----------
			-- RADIO --
			-----------
			c06: port RADIO.send_data -> radio_send;
			c07: port RADIO.AutomationRequest -> AM_Gate.AutomationRequest_in;
			c08: port RADIO.OperatingRegion -> AM_Gate.OperatingRegion_in;
			c09: port RADIO.LineSearchTask -> AM_Gate.LineSearchTask_in;
			c10: port RADIO.am_response -> AM.attestation_response;

			--------------
			-- FlyZones --
			--------------
			c11: port FlyZones.keep_in_zones -> MON_GEO.keep_in_zones;
			c12: port FlyZones.keep_out_zones -> MON_GEO.keep_out_zones;

			----------
			-- UXAS --
			----------
			c13: port UXAS.AutomationResponse -> FLT_ARes.filter_in;

			---------
			-- WPM --
			---------
			c15: port WPM.MissionCommand -> FC_UART.MissionCommand;

			--------
			-- AM --
			--------
			c16: port AM.attestation_request -> RADIO.am_request;
			c17: port AM.trusted_ids -> AM_Gate.trusted_ids;

			-------------
			-- AM_GATE --
			-------------
			c18: port AM_Gate.AutomationRequest_out -> FLT_AReq.filter_in;
			c19: port AM_Gate.OperatingRegion_out -> FLT_OR.filter_in;
			c20: port AM_Gate.LineSearchTask_out -> FLT_LST.filter_in;

			-------------
			-- FILTERS --
			-------------
			c22: port FLT_AReq.filter_out_UXAS -> UXAS.AutomationRequest;
			c23: port FLT_AReq.filter_out_MON_REQ -> MON_REQ.reqt;
			c24: port FLT_OR.filter_out -> UXAS.OperatingRegion;
			c25: port FLT_LST.filter_out -> UXAS.LineSearchTask;
			c26: port FLT_ARes.filter_out -> MON_REQ.resp;
			c27: port FLT_ARes.filter_out -> MON_GEO.observed;

			--------------
			-- MONITORS --
			--------------
			c28: port MON_GEO.output -> WPM.AutomationResponse;
			c29: port MON_GEO.alert -> WPM.ReturnHome;
			c30: port MON_REQ.alert -> ALERT_SYNC.alert_in;
			
		properties
			Actual_Processor_Binding => (reference (proc)) applies to FC_UART;
            Actual_Processor_Binding => (reference (proc)) applies to RADIO;
            Actual_Processor_Binding => (reference (proc)) applies to FlyZones;
            Actual_Processor_Binding => (reference (proc)) applies to UXAS;
            Actual_Processor_Binding => (reference (proc)) applies to WPM;
			Actual_Processor_Binding => (reference (proc)) applies to AM;
            Actual_Processor_Binding => (reference (proc)) applies to AM_GATE;
            Actual_Processor_Binding => (reference (proc)) applies to FLT_LST;
			Actual_Processor_Binding => (reference (proc)) applies to FLT_AReq;
			Actual_Processor_Binding => (reference (proc)) applies to FLT_ARes;
			Actual_Processor_Binding => (reference (proc)) applies to FLT_OR;
            Actual_Processor_Binding => (reference (proc)) applies to MON_REQ;
            Actual_Processor_Binding => (reference (proc)) applies to ALERT_SYNC;
            Actual_Processor_Binding => (reference (proc)) applies to MON_GEO;

            HAMR::Default_Bit_Width => 32;
            HAMR::Default_Max_Sequence_Size => 1;
            HAMR::Max_String_Size => 256;
            HAMR::Bit_Codec_Raw_Connections => true;

        annex resolute {**
            check CASE_Tools
        **};

        annex agree {**
            -------------------------------------------------
            -- The system only responds to trusted sources --
            -------------------------------------------------
            eq trusted_ids : CMASI::AddressArray.i = AM.trusted_ids;
            eq trustedAutomationRequest : bool =
                (event(UXAS.AutomationRequest) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.AutomationRequest.id)
                      and RADIO.AutomationRequest.payload.AutomationRequest = UXAS.AutomationRequest
                    ));
            eq trustedLineSearchTask : bool =
                (event(UXAS.LineSearchTask) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.LineSearchTask.id)
                      and RADIO.LineSearchTask.payload.LineSearchTask = UXAS.LineSearchTask
                    ));
            eq trustedOperatingRegion : bool =
                (event(UXAS.OperatingRegion) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.OperatingRegion.id)
                      and RADIO.OperatingRegion.payload.OperatingRegion = UXAS.OperatingRegion
                    ));
            assign trustedSourcesOnly =
                (     trustedAutomationRequest
                  and trustedLineSearchTask
                  and trustedOperatingRegion
                );

            --------------------------------------------
            -- The uart_send waypoints are geo-fenced --
            --------------------------------------------
            eq keep_in_zones : CMASI::Polygon.i = FlyZones.keep_in_zones;
            eq keep_out_zones: CMASI::Polygon.i = FlyZones.keep_out_zones;
            
            eq obeysKeepInZones : bool =
                (event(WPM.AutomationResponse) =>
                    WAYPOINTS_IN_ZONE(GET_MISSION_COMMAND(WPM.AutomationResponse), keep_in_zones)
                );
            eq obeysKeepOutZones : bool =
                (event(WPM.AutomationResponse) =>
                    WAYPOINTS_NOT_IN_ZONE(GET_MISSION_COMMAND(WPM.AutomationResponse), keep_out_zones)
                );
            eq noDuplicates : bool =
                (event(WPM.AutomationResponse) =>
                    not (DUPLICATES_IN_MISSION(GET_MISSION_COMMAND(WPM.AutomationResponse)))
                );
            assign geoFenced = 
                (     obeysKeepInZones
                  and obeysKeepOutZones
                  and noDuplicates
                );

            -----------------------------------------------------------
            -- The uart_send waypoints correspond to the line search --
            -----------------------------------------------------------
            assign waypointsFromLineSearch =
                (event(WPM.AutomationResponse) =>
                    IS_SUBSET_OF_LOCATIONS(UXAS.LineSearchTask.PointList,
                        WPM.AutomationResponse.MissionCommandList[0])
                );

            -------------------------------------------- 
            -- Geo-fenced is as strong as well-formed --
            --------------------------------------------
            eq UxasObeysKeepInZones : bool =
                (event(UXAS.AutomationResponse) =>
                    WAYPOINTS_IN_ZONE(GET_MISSION_COMMAND(UXAS.AutomationResponse), keep_in_zones));
            eq UxasObeysKeepOutZones : bool =
                (event(UXAS.AutomationResponse) =>
                    WAYPOINTS_NOT_IN_ZONE(GET_MISSION_COMMAND(UXAS.AutomationResponse), keep_out_zones));
            eq UxasWellFormedAutomationResponse : bool =
                event(UXAS.AutomationResponse) =>
                    WELL_FORMED_AUTOMATION_RESPONSE(UXAS.AutomationResponse);

            lemma "Well-formed Geo-fence implies the automation response is well-formed" :
                (UxasObeysKeepInZones and UxasObeysKeepOutZones) =>
                   UxasWellFormedAutomationResponse;
        **};   
	end SW.Impl;
    
    system implementation SW.NO_MON_GEO_Impl
        subcomponents
            proc: processor proc.Impl;
            FC_UART: process UARTDriver.Impl;
            RADIO: process RadioDriver_Attestation.Impl;
            UXAS: process UxAS.Impl;
            WPM: process WaypointPlanManagerService.Impl;
            AM: process CASE_AttestationManager.Impl;
            AM_Gate: process CASE_AttestationGate.Impl;
            FLT_AReq: process CASE_Filter_AReq.Impl;
            FLT_OR: process CASE_Filter_OR.Impl;
            FLT_LST: process CASE_Filter_LST.Impl;
            MON_REQ: process CASE_Monitor_Req.Impl;
            ALERT_SYNC: process alert_sync.Impl;
            FLT_ARes: process CASE_Filter_ARes.Impl;
        connections

            ------------------
            -- Primary Inputs
            ------------------
            c01: port uart_recv -> FC_UART.recv_data;
            c02: port radio_recv -> RADIO.recv_data;

            -----------
            -- FC_UART
            -----------
            c03: port FC_UART.send_data -> uart_send;
            c04: port FC_UART.AirVehicleState_UXAS -> UXAS.AirVehicleState;
            c05: port FC_UART.AirVehicleState_WPM -> WPM.AirVehicleState;

            ---------
            -- RADIO
            ---------
            c06: port RADIO.send_data -> radio_send;
            c07: port RADIO.AutomationRequest -> AM_Gate.AutomationRequest_in;
            c08: port RADIO.OperatingRegion -> AM_Gate.OperatingRegion_in;
            c09: port RADIO.LineSearchTask -> AM_Gate.LineSearchTask_in;
            c10: port RADIO.am_response -> AM.attestation_response;

            --------
            -- UXAS
            --------
            c13: port UXAS.AutomationResponse -> FLT_ARes.filter_in;

            --------
            -- WPM
            --------
            c15: port WPM.MissionCommand -> FC_UART.MissionCommand;

            -------
            -- AM
            -------
            c16: port AM.attestation_request -> RADIO.am_request;
            c17: port AM.trusted_ids -> AM_Gate.trusted_ids;

            -----------
            -- AM_GATE
            ------------
            c18: port AM_Gate.AutomationRequest_out -> FLT_AReq.filter_in;
            c19: port AM_Gate.OperatingRegion_out -> FLT_OR.filter_in;
            c20: port AM_Gate.LineSearchTask_out -> FLT_LST.filter_in;

            ------------
            -- FILTERS
            ------------
            c22: port FLT_AReq.filter_out_UXAS -> UXAS.AutomationRequest;
            c23: port FLT_AReq.filter_out_MON_REQ -> MON_REQ.reqt;
            c24: port FLT_OR.filter_out -> UXAS.OperatingRegion;
            c25: port FLT_LST.filter_out -> UXAS.LineSearchTask;
            c26: port FLT_ARes.filter_out -> MON_REQ.resp;
            c27: port FLT_ARes.filter_out -> WPM.AutomationResponse;

            -------------
            -- MONITORS
            -------------
            c30: port MON_REQ.alert -> ALERT_SYNC.alert_in;
            
        properties
            Actual_Processor_Binding => (reference (proc)) applies to FC_UART;
            Actual_Processor_Binding => (reference (proc)) applies to RADIO;
            Actual_Processor_Binding => (reference (proc)) applies to UXAS;
            Actual_Processor_Binding => (reference (proc)) applies to WPM;
            Actual_Processor_Binding => (reference (proc)) applies to AM;
            Actual_Processor_Binding => (reference (proc)) applies to AM_GATE;
            Actual_Processor_Binding => (reference (proc)) applies to FLT_LST;
            Actual_Processor_Binding => (reference (proc)) applies to FLT_AReq;
            Actual_Processor_Binding => (reference (proc)) applies to FLT_ARes;
            Actual_Processor_Binding => (reference (proc)) applies to FLT_OR;
            Actual_Processor_Binding => (reference (proc)) applies to MON_REQ;
            Actual_Processor_Binding => (reference (proc)) applies to ALERT_SYNC;

            HAMR::Default_Bit_Width => 32;
            HAMR::Default_Max_Sequence_Size => 1;
            HAMR::Max_String_Size => 256;
            HAMR::Bit_Codec_Raw_Connections => true;

        annex resolute {**
            check CASE_Tools
        **};

        annex agree {**
            -------------------------------------------------
            -- The system only responds to trusted sources --
            -------------------------------------------------
            eq trusted_ids : CMASI::AddressArray.i = AM.trusted_ids;
            eq trustedAutomationRequest : bool =
                (event(UXAS.AutomationRequest) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.AutomationRequest.id)
                      and RADIO.AutomationRequest.payload.AutomationRequest = UXAS.AutomationRequest
                    ));
            eq trustedLineSearchTask : bool =
                (event(UXAS.LineSearchTask) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.LineSearchTask.id)
                      and RADIO.LineSearchTask.payload.LineSearchTask = UXAS.LineSearchTask
                    ));
            eq trustedOperatingRegion : bool =
                (event(UXAS.OperatingRegion) =>
                    (     IS_TRUSTED(trusted_ids, RADIO.OperatingRegion.id)
                      and RADIO.OperatingRegion.payload.OperatingRegion = UXAS.OperatingRegion
                    ));
            assign trustedSourcesOnly =
                (     trustedAutomationRequest
                  and trustedLineSearchTask
                  and trustedOperatingRegion
                );

            --------------------------------------------
            -- The uart_send waypoints are geo-fenced --
            --------------------------------------------
            eq keep_in_zones : CMASI::Polygon.i;
            assert(WELL_FORMED_ZONES(keep_in_zones));
            eq keep_out_zones: CMASI::Polygon.i;
            assert(WELL_FORMED_ZONES(keep_out_zones));
            assert(event(WPM.ReturnHome) = false);
            
            eq obeysKeepInZones : bool =
                (event(WPM.AutomationResponse) =>
                    WAYPOINTS_IN_ZONE(GET_MISSION_COMMAND(WPM.AutomationResponse), keep_in_zones)
                );
            eq obeysKeepOutZones : bool =
                (event(WPM.AutomationResponse) =>
                    WAYPOINTS_NOT_IN_ZONE(GET_MISSION_COMMAND(WPM.AutomationResponse), keep_out_zones)
                );
            eq noDuplicates : bool =
                (event(WPM.AutomationResponse) =>
                    not (DUPLICATES_IN_MISSION(GET_MISSION_COMMAND(WPM.AutomationResponse)))
                );
            assign geoFenced = 
                (     obeysKeepInZones
                  and obeysKeepOutZones
                  and noDuplicates
                );

            -----------------------------------------------------------
            -- The uart_send waypoints correspond to the line search --
            -----------------------------------------------------------
            assign waypointsFromLineSearch =
                (event(WPM.AutomationResponse) =>
                    IS_SUBSET_OF_LOCATIONS(UXAS.LineSearchTask.PointList,
                        WPM.AutomationResponse.MissionCommandList[0])
                );
        **};
    end SW.NO_MON_GEO_Impl;
end SW;
